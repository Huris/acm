

 hash
1)	hash表又称为散列表,一般由hash函数与链表结构共同实现。
    与离散化思想类似,当我们要对若干复杂信息进行统计时,可以用hash函数把这些复杂信息映射到一个容易维护的值域内。
    因为值域变简单,范围变小,有可能造成两个不同的原始信息被hash函数映射为相同的值,故我们要解决好这种冲突的情况
2)	开散列
  a)	建立一个邻接表,以hash函数的值域作为表头数组,映射后的值相同的原始信息被分到同一类,
      构成一个链表接在对应的表头之后,链表的结点上可以保存原始信息和一些统计数据
  b)	 hash表主要包括两个基本操作
    (1)	计算hash函数的值
    (2)	定位到对应链表中依次遍历,比较
		无论是检查任意一个给定的原始信息在hash表中是否存在,还是更新它在hash表
	 中的统计数据,都需要基于这两个基本操作执行
3)	当hash函数设计的较好时,原始信息会被比较均匀地分配到各个表头之后,从而使每次查找,统计的时间降低到原始信息总数除以表头数组长度。
4)	在一个长度为n的随机整数序列中统计每个数出现了几次
  a)	设计hash函数为
          h ( x ) = ( x mod p) + 1    (其中p为一个不超过n的比较大的质数)
  b)	显然,这个hash函数把数列a分成p类,我们可以依次考虑数列中的每一个a[i],定位到head[ h(a[i]) ]这个表头所指向的链表,
      如果该链表不包含a[i],我们就在表头后插入一个新结点a[i],并在该结点上记录a[i]出现1次,否则我们就直接找到已经存在的a[i]结点将其出现次数加1。
      因为整数序列a是随机的,所以最终所有的a[i]会比较均匀地分散在各个表头之后,整个算法的时间复杂度可以接近为O(n)
5)	字符串hash(把一个任意长度的字符串映射成一个非负整数,并且其冲突的概率为0)
  a)	令p = 13331 , 把字符串看做是p进制数    
  b)	令a=1,b=2,c=3,…,z=26  (有大写字母的话,可以弄到52)
  c)	令mod=264,求出该p进制数对mod的余数,作为该字符串的hash值
        mod为unsigned long long 值的最大值,在计算时不处理算术溢出问题,产生溢出
      时相当于自动对2^64取模,这样可以避免低效的取模运算
        即:当h数组为unsigned long long时
             h[i]=h[i-1]*p+s[i]- 'a'+1;	//不需要取模运算,自动取模
  d)	对字符串的操作,都可以直接对p进制数进行算术运算反应到hash值上
    i)	字符串s的hash值  h(s)  则在s之后添加一个字符c构成的新字符串s+c的hash值为   h( s + c ) = ( h(s) * p + (c-'a'+1) ) %mod 
    ii)	字符串s的hash值  h(s)   字符串s+t的hash值  h(s+t)
             则字符串t的hash值   h( t ) = (h(s+t) – h(s) * plen( t ) )%mod
    iii)	例如 s =“abc” ,  c = 'd'  ,  t =“xyz”
      (1)	h(s)=1*p2+2*p+3
      (2)	h(s+c)=1*p3+2* p2+3*p+4
      (3)	h(s+t)= 1*p5+2* p4+3*p3+24*p2+25* p+26
      (4)	h(t) = h(s+t) – h(s)*plen(t) = 24*p2+25* p+26
      iv)	根据上面两种操作,我们可以通过O(n)的时间预处理字符串所有前缀hash值,并在O(1)的时间内查询它的任意子串的hash值
      v)	给一个字符串,给两个区间,判断两个区间内的字符串是否相等
              //f[i]表示前缀子串s[1~i]的hash值
              //即f[i]=f[i-1]*p+s[i]-'a'+1
              //于是我们可以得到任意区间[l,r]的hash值为
              //  hash[l~r] = f [ r ] – f [ l – 1 ] *pr-l+1
              //整个算法复杂度为O(s+q)
              char s[1000010];
              unsigned long long f[1000010],p[1000010];
              int main()
              {
                  int n,q;
                  cin>>n>>q;
                  scanf("%s",s+1);
                  p[0]=1;   //
                  for(int i=1;i<=n;i++)
                  {
                      f[i]=f[i-1]*13331+s[i]-'a'+1;   //hash of 1~i
                      p[i]=p[i-1]*13331;      //13331^i
                  }
                  while (q--)
                  {
                      int l1,l2,r1,r2;
                      scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
                      if(f[r1]-f[l1-1]*p[r1-l1+1]==
                         f[r2]-f[l2-1]*p[r2-l2+1])printf("Yes\n");
                      else printf("No\n");
                  }
              }
