


并查集(Disjoint-set)( 动态维护若干个不重叠的集合,并支持合并与查询的数据结构)
  1)	两个基本操作
    a)	get    查询一个元素属于哪个集合
    b)	merge    把两个集合合并成一个大集合
  2)	算法
    a)	在并查集中,我们采用“代表元”法,即为每个元素选择一个固定的元素,作为整个集合的“代表”
    b)	使用一棵树形结构存储每个集合,树上的每个节点都是一个元素,树根是集合的代表元素,整个并查集实际上是一个森林(若干棵树)
    c)	我们使用fa[x]保存x的父亲结点,特别的,令树根的fa值为它自己,这样一来,合并另个集合是,
        只需连接两个树根(令其中一个树根为另外一个树根的子节点,即fa[r1]=r2),不过,在查询元素的归属时,
        需要从该元素开始通过fa存储的值不断递归访问父亲结点,直至到达树根
    d)	为了提高查询效率,可以使用路径压缩和按秩合并两种思想
  3)	路径压缩
    a)	实际上,我们只关心每个集合对应的树形结构的根节点是什么,并不关心这棵树的具体形态
    b)	因此我们在每次执行get操作的同时,把访问过的每个节点(也就是所查询元素的全部祖先)都直接指向树根    路径压缩
    c)	采用路径压缩优化的并查集,每次get操作的均摊复杂度为O(logn)
  4)	具体实现
    a)	并查集的存储
    使用一个数组fa保存父亲结点(根的父亲结点设为自己)
    int fa[N];
    b)	并查集初始化
    设有n个元素,起初所有元素各自构成一个独立的集合,既有n棵1个点的树
    for(int i=1;i<=n;i++)fa[i] = i ;
    c)	并查集的get操作
    若x是树根,则x就是集合的代表元素,否则递归访问fa[x]直至根结点
    int get(int x) {
       if(x==fa[x])return x;
       return fa[x]=get(fa[x]);
    }
    d)	并查集的merge操作
    合并元素x和元素y所在的集合,等价于让x的树根作为y的树根的子节点
    int un(int a,int b)
    {
        int aa=fi(a),bb=fi(b);
        if(aa!=bb)
        {
            fa[bb]=aa;
            return 0;
        }
        return 1;
    }
  5)	并查集能在一张无向图中维护结点之间的连通性,这是它的基本用途之一,实际上,并查集擅长动态维护许多具有传递性的关系
  6)	“扩展域”与“带边权”的并查集
      并查集实际上是由若干棵树构成的森林,我们可以在树中的每条边上记录一个权值,
      即维护一个数组d,用d[x]保存结点x到父亲结点fa[x]之间的边权,在每次路径压缩之后,
      每个访问过的结点都会直接指向根结点,如果我们同时更新这些结点的d值,
      就可以利用路径压缩过程来统计每个结点到树根之间的路径上的一些信息,这就是所谓的“带边权”的并查
