


最小表示法
  1)	给定一个字符串s[1~n],如果我们不断把它的最后一个字符放到开头,最终会得到n个字符串,
      称这n个字符串是循环同构的,其中,这些字符串中字典序最小的一个,称为字符串s的最小表示
  2)	O(n)求最小表示
    a)	首先把s复制一份接在它的结尾,得到的字符串称为ss,记b[i]表示从i开始的循环同构字符串,显然b[i]=ss[ i ~ i+n-1 ]
    b)	对于任意的i , j ,我们仔细观察b[i]与b[j]的比较过程,如果在i+k与j+k处发现不相等,
        假设ss[i+k]>ss[j+k],那么我们当然可以得知b[i]不是s的最小表示(因为存在一个更小的循环同构串b[j]),
        除此之外,我们还可以得知b[i+1], b[i+2]… b[i+k]也都不是s的最小表示,
        这是因为对于1<=p<=k,存在一个比b[i+p]更小的循环同构串b[ j+p](从i+p与j+p开始向后扫描,同样会在p=k时发现不相等,并且ss[i+k]>ss[j+k]),
        同理,对于ss[i+k]<ss[j+k], b[j+1], b[j+2]… b[j+k]也都不是最小表示,直接跳过这些位置
    c)	算法
        i)	初始化i=1,j=2
        ii)	通过直接向后扫描的方法,比较b[i]与b[j]两个循环同构串
          (1)	如果扫描了n个字符后仍然相等,说明s只由一种字符构成,任意b[i]都是最小表示
          (2)	如果在i+k与j+k处发现不相等
            (a)	若ss[i+k]>ss[j+k],令i=i+k+1,若此时i=j,再令i++
            (b)	若ss[i+k]<ss[j+k],令j=j+k+1,若此时i=j,再令j++
          (3)	若i>n,b[j]为最小表示,若j>n,b[i]为最小表示,否则重复第2步
          
    d)代码
        char s[1001];
        int main()
        {
            int n;      //n为字符串s的长度
            scanf("%d%s",&n,s+1);
            for(int i=1;i<=n;i++)s[n+i]=s[i];
            int i=1,j=2,k;
            while(i<=n&&j<=n)
            {
                for(k=0;k<n&&s[i+k]==s[j+k];k++);
                if(k==n)break;
                if(s[i+k]>s[j+k])
                {
                    i=i+k+1;
                    if(i==j)i++;
                }
                else
                {
                    j=j+k+1;
                    if(i==j)j++;
                }
            }
            int ans=min(i,j);   //b[ans]就是最小表示
        }
